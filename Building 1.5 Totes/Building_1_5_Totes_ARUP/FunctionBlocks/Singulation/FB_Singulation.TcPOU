<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.4">
  <POU Name="FB_Singulation" Id="{90a9a1ab-2280-409c-80d5-149a5fd26eda}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_Singulation
VAR_INPUT
	{attribute 'OPC.UA.DA' := '1'}
	In_ResetState			:	BOOL;	// Clear the current functional state of the Singulator
	In_Pause				:	BOOL;
	In_FaultReset			:	BOOL;
	In_EncoderCount			:	UINT;	// Current encoder Pulse Count
	In_PE_GrabTrigger		:	BOOL;
	In_PE_ToteTrigger		:	BOOL;
	In_PE_ClearedTrigger	:	BOOL;
	In_ConveyorRunning		:	BOOL;
	
	In_Grabber_1_Auto		:	BOOL;
	In_Grabber_1_Extended	:	BOOL;
	In_Grabber_1_Retracted	:	BOOL;

	In_Grabber_2_Auto		:	BOOL;
	In_Grabber_2_Extended	:	BOOL;
	In_Grabber_2_Retracted	:	BOOL;

	In_PinStop_Auto			:	BOOL;
	In_PinStop_Extended		:	BOOL;
	In_PinStop_Retracted	:	BOOL;

	Cfg_GappingDistance		:	UINT;	// Distance in encoder Pulses before the next item can be released
	Cfg_TimeOutTime			:	TIME := T#3S;
	Cfg_RetryLimit			:	UINT;
END_VAR
VAR_OUTPUT
	Out_ReleaseFault		:	BOOL;

	Out_Grabber_1_Ext		:	BOOL;
	Out_Grabber_1_Ret		:	BOOL;

	Out_Grabber_2_Ext		:	BOOL;
	Out_Grabber_2_Ret		:	BOOL;

	Out_PinStop_Ext			:	BOOL;
	Out_PinStop_Ret			:	BOOL;

	Out_Homed				:	BOOL;
	Out_Ready				:	BOOL;
	Out_Running				:	BOOL;
	
	Status_Output			:	UINT;
	Status					:	UINT;
END_VAR
VAR	
	SingulatorClear			:	BOOL:= FALSE;

	RolloverDetect			:	UINT;	// Capture the last Distance when the Encoder count goes to zero
	GrabTrigger				:	R_TRIG;
	ClearedTriggerPE		:	F_TRIG;
	
	StartUp					:	BOOL := TRUE;

	ClearedPECount			:	UINT;	// Encoder Pulses when ClearedTriggerPE triggered
	ClearedDistance			:	UINT;	// Distance traveled since last item cleared
	Releasing				:	BOOL;
	ReleaseTimeOut			:	TON;
	BadReleaseCount			:	UINT;
	BadReleaseCount_Old		:	UINT;
	BadReleaseReTryTimer	:	TON;
	BadReleaseRetry			:	BOOL;

	rResetState				:	R_TRIG;

	tonHomeWait				:	TON := (PT := T#1S);
	tonReadyWait			:	TON := (PT := T#1S);
	tonRunningWait			:	TON := (PT := T#5S);

	// Extend and Retract controls
	Grabber_1_Extend		:	BOOL;
	Grabber_1_Retract		:	BOOL;

	Grabber_2_Extend		:	BOOL;
	Grabber_2_Retract		:	BOOL;

	PinStop_Extend			:	BOOL;
	PinStop_Retract			:	BOOL;
END_VAR

VAR CONSTANT
	// Output Status
	GRABBER_1_OCCUPIED		:	UINT  := 1;
	GRABBER_2_OCCUPIED		:	UINT  := 2;
	PINSTOP_OUT				:	UINT  := 3;
	
	// Singulation Status
	PAUSED					:	UINT  := 0;
	PRODUCT_PRESENT			:	UINT  := 1;
	PRODUCT_ENTERING_OCR	:	UINT  := 2;
	PRODUCT_READY_TO_PROCESS:	UINT  := 3;
	OCR_FINISHED			:	UINT  := 4;	
	PRODUCT_EXITING_OCR		:	UINT  := 5;
	RETURN_CONVEYOR_CLEARING:	UINT  := 6;
	RETURN_CONVEYOR_BUSY	:	UINT  := 7;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[// Process the In_ResetState
rResetState(CLK:=In_ResetState);

IF rResetState.Q OR (In_FaultReset AND Out_ReleaseFault) THEN
	// Revert to the StartUp state
	StartUp := TRUE;
	// Revert to the NOT Homed state
	Out_Homed := FALSE;
	tonHomeWait(IN := FALSE);
	// Revert to the NOT Ready state
	Out_Ready := FALSE;
	tonReadyWait(IN := FALSE);
	// Revert to the NOT Running state
	Out_Running := FALSE;
	tonRunningWait(IN := FALSE);

	Out_ReleaseFault := FALSE;
	BadReleaseCount := 0;
	
	Releasing := FALSE;

	// Clear the reset request
	In_ResetState := FALSE;
END_IF

(*
// Clear Fault on fault reset
IF In_FaultReset THEN
	BadReleaseCount := 0;
	Out_ReleaseFault := FALSE;
	a_ResetGrabbers();
END_IF
*)

SingulatorClear := (NOT In_PE_GrabTrigger AND NOT In_PE_ClearedTrigger AND NOT In_PE_ToteTrigger);
IF StartUp AND NOT SingulatorClear THEN
	Out_ReleaseFault := TRUE;
	StartUp := FALSE;
END_IF

// Home the actuators
IF (StartUp OR NOT Out_Homed OR NOT Out_Ready) AND SingulatorClear THEN
	Status.PAUSED := TRUE;
	
	tonHomeWait.IN := NOT Out_Homed;
	tonHomeWait();

	// Homed is Grabbers retracted and PinStop retracted
	IF NOT Out_Homed THEN
		// Grabber 1
		Grabber_1_Retract := TRUE;
		Grabber_1_Extend := FALSE;
		// Grabber 2
		Grabber_2_Retract := TRUE;
		Grabber_2_Extend := FALSE;
		// PinStop
		PinStop_Retract := TRUE;
		PinStop_Extend := FALSE;
		IF In_Grabber_1_Retracted
		   AND In_Grabber_2_Retracted
		   AND In_PinStop_Retracted
		   THEN
			Out_Homed := tonHomeWait.Q;
		END_IF
	END_IF

	// Ready is Grabbers retracted and PinStop extended
	// All PE's have to be clear for the equipment to be ready
	tonReadyWait.IN := NOT Out_Ready AND Out_Homed AND NOT In_PE_GrabTrigger AND NOT In_PE_ClearedTrigger AND NOT In_PE_ToteTrigger;
	tonReadyWait();
	IF NOT Out_Ready AND Out_Homed AND tonReadyWait.IN THEN
		// PinStop
		PinStop_Retract := FALSE;
		PinStop_Extend := TRUE;
		IF In_Grabber_1_Retracted
		   AND In_Grabber_2_Retracted
		   AND In_PinStop_Extended
		   THEN
			Out_Ready := tonReadyWait.Q;
		END_IF
	END_IF

	StartUp := NOT Out_Homed OR NOT Out_Ready;
	Out_Running := FALSE;
	BadReleaseCount := 0;
	Out_ReleaseFault := FALSE;
	Releasing := FALSE;

ELSIF In_Pause OR NOT In_ConveyorRunning THEN

	// Grabber 1
	Grabber_1_Retract := FALSE;
	Grabber_1_Extend := FALSE;
	// Grabber 2
	Grabber_2_Retract := FALSE;
	Grabber_2_Extend := FALSE;
	// PinStop
	PinStop_Retract := FALSE;
	PinStop_Extend := FALSE;

ELSIF NOT Out_Running THEN

	tonRunningWait.IN := NOT OUT_Running AND Out_Ready AND Out_Homed AND In_ConveyorRunning;
	tonRunningWait();
	Out_Running := tonRunningWait.Q;

ELSIF Out_Running THEN
	
	//Watch Grabbing Trig
	GrabTrigger(CLK:= In_PE_GrabTrigger);

	// Stop Product
	IF GrabTrigger.Q THEN
		a_HoldProduct();
	END_IF

	// Retry release if Bad release
	BadReleaseRetry := (BadReleaseCount > 0) AND (BadReleaseCount <> BadReleaseCount_Old) AND NOT Out_ReleaseFault;
	BadReleaseReTryTimer(IN:= BadReleaseRetry, PT:= T#1S);
	IF BadReleaseReTryTimer.Q THEN
		a_HoldProduct();
		BadReleaseCount_Old := BadReleaseCount;
	END_IF

	// Singulation Distance Check
	IF In_EncoderCount > ClearedPECount THEN
		ClearedDistance := In_EncoderCount - ClearedPECount;
		RolloverDetect := 0;
	ELSE
		// If the encoder rolls to 0, capture the last distance as an offset
		IF RolloverDetect = 0 THEN
			RolloverDetect := ClearedDistance;
		END_IF
		// The new distance to check is the number of pulses from the Cleared count to the rollover (RolloverDetect)
		// 	plus the current encoder count
		ClearedDistance := RolloverDetect + In_EncoderCount;
	END_IF

	// Release After Distance Requirement is satisfied
	IF ClearedDistance > Cfg_GappingDistance THEN
	
		// Test for an item at the pin stop
		IF In_PE_GrabTrigger THEN
			// If upper PE is blocked then release gripper so Tote can move
			IF In_PE_ToteTrigger THEN
				// Grabber 2
				Grabber_2_Retract := TRUE;
				Grabber_2_Extend := FALSE;
			END_IF
		
			// PinStop
			PinStop_Retract := TRUE;
			PinStop_Extend := FALSE;
			Releasing := TRUE;
		END_IF
	END_IF

	// Watch release to make sure product comes through, set timer if not
	ReleaseTimeOut(IN:= Releasing, PT:= Cfg_TimeOutTime, Q=> , ET=> );

	// Watch for released cleared PE
	ClearedTriggerPE(CLK:= (Releasing AND In_PE_ClearedTrigger));

	IF ClearedTriggerPE.Q THEN
		BadReleaseCount := 0;
		a_ResetGrabbers();
		ClearedPECount := In_EncoderCount;
	ELSIF ReleaseTimeOut.Q THEN
		a_ResetGrabbers();
		BadReleaseCount := BadReleaseCount + 1;
	END_IF

	// Watch for Fault
	IF BadReleaseCount >= Cfg_RetryLimit THEN
		Out_ReleaseFault := TRUE;
	END_IF

	// If fault Hold until user clears it
	IF Out_ReleaseFault THEN
		a_HoldProduct();
		// PinStop
		PinStop_Retract := FALSE;
		PinStop_Extend := FALSE;
	END_IF
ELSE
	// Grabber 1
	Grabber_1_Retract := TRUE;
	Grabber_1_Extend := FALSE;
	// Grabber 2
	Grabber_2_Retract := TRUE;
	Grabber_2_Extend := FALSE;
	// PinStop
	PinStop_Retract := FALSE;
	PinStop_Extend := TRUE;

END_IF

// Activate all the outputs in one place
Status_Output.GRABBER_1_OCCUPIED := Grabber1(Active := In_Grabber_1_Auto, Extend:= Grabber_1_Extend, Retract := Grabber_1_Retract);
Status_Output.GRABBER_2_OCCUPIED := Grabber2(Active := In_Grabber_2_Auto, Extend:= Grabber_2_Extend, Retract := Grabber_2_Retract);
Status_Output.PINSTOP_OUT := PinStop(Active:= In_PinStop_Auto, Extend := PinStop_Extend, Retract:= PinStop_Retract);
]]></ST>
    </Implementation>
    <Action Name="a_HoldProduct" Id="{7f5172fb-ebc5-4859-80c8-0ce199410c44}">
      <Implementation>
        <ST><![CDATA[// Grabber 1
Grabber_1_Retract := FALSE;
Grabber_1_Extend := TRUE;
// Grabber 2
Grabber_2_Retract := FALSE;
Grabber_2_Extend := TRUE;]]></ST>
      </Implementation>
    </Action>
    <Action Name="a_ResetGrabbers" Id="{0f6d0a35-4d6a-444f-b0fc-0d8b5f006497}">
      <Implementation>
        <ST><![CDATA[// Grabber 1 Retract
Grabber_1_Retract := TRUE;
Grabber_1_Extend := FALSE;
// Grabber 2 Retract
Grabber_2_Retract := TRUE;
Grabber_2_Extend := FALSE;
// PinStop Extend
PinStop_Retract := FALSE;
PinStop_Extend := TRUE;
// Reset Releasing
Releasing := FALSE;]]></ST>
      </Implementation>
    </Action>
    <Method Name="Grabber1" Id="{4c24c07a-cb45-4f62-9a61-e207017251fa}">
      <Declaration><![CDATA[METHOD Grabber1 : BOOL
VAR_INPUT
	Active	: BOOL;	
	Extend	: BOOL;
	Retract	: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF Active THEN
	IF Extend THEN
		Out_Grabber_1_Ext := TRUE;
		Out_Grabber_1_Ret := FALSE;
	ELSIF Retract THEN
		Out_Grabber_1_Ext := FALSE;
		Out_Grabber_1_Ret := TRUE;
	ELSE
		Out_Grabber_1_Ext := FALSE;
		Out_Grabber_1_Ret := FALSE;
	END_IF
ELSE
	Out_Grabber_1_Ext := FALSE;
	Out_Grabber_1_Ret := FALSE;
END_IF

Grabber1 := Out_Grabber_1_Ext OR In_Grabber_1_Extended;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Grabber2" Id="{be900dd0-b95c-49fe-a4c7-a6c5b69d06d1}">
      <Declaration><![CDATA[METHOD Grabber2 : BOOL
VAR_INPUT
	Active	: BOOL;	
	Extend	: BOOL;
	Retract	: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF Active THEN
	IF Extend THEN
		Out_Grabber_2_Ext := TRUE;
		Out_Grabber_2_Ret := FALSE;
	ELSIF Retract THEN
		Out_Grabber_2_Ext := FALSE;
		Out_Grabber_2_Ret := TRUE;
	ELSE
		Out_Grabber_2_Ext := FALSE;
		Out_Grabber_2_Ret := FALSE;
	END_IF
ELSE
	Out_Grabber_2_Ext := FALSE;
	Out_Grabber_2_Ret := FALSE;
END_IF

Grabber2 := Out_Grabber_2_Ext OR In_Grabber_2_Extended;]]></ST>
      </Implementation>
    </Method>
    <Method Name="PinStop" Id="{a2c42692-ac29-4ee3-9efe-a4c8eef09923}">
      <Declaration><![CDATA[METHOD PinStop : BOOL
VAR_INPUT
	Active	: BOOL;	
	Extend	: BOOL;
	Retract	: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF Active THEN
	IF Extend THEN
		Out_PinStop_Ext := TRUE;
		Out_PinStop_Ret := FALSE;
	ELSIF Retract THEN
		Out_PinStop_Ext := FALSE;
		Out_PinStop_Ret := TRUE;
	ELSE
		Out_PinStop_Ext := FALSE;
		Out_PinStop_Ret := FALSE;
	END_IF
ELSE
	Out_PinStop_Ext := FALSE;
	Out_PinStop_Ret := FALSE;
END_IF

PinStop := Out_PinStop_Ext OR In_PinStop_Extended;]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_Singulation">
      <LineId Id="2462" Count="3" />
      <LineId Id="2468" Count="10" />
      <LineId Id="2735" Count="0" />
      <LineId Id="2734" Count="0" />
      <LineId Id="2736" Count="0" />
      <LineId Id="2616" Count="1" />
      <LineId Id="2739" Count="0" />
      <LineId Id="2737" Count="1" />
      <LineId Id="2481" Count="0" />
      <LineId Id="2733" Count="0" />
      <LineId Id="2740" Count="0" />
      <LineId Id="2727" Count="5" />
      <LineId Id="2461" Count="0" />
      <LineId Id="2742" Count="1" />
      <LineId Id="2741" Count="0" />
      <LineId Id="2748" Count="0" />
      <LineId Id="2752" Count="0" />
      <LineId Id="2749" Count="0" />
      <LineId Id="2751" Count="0" />
      <LineId Id="2502" Count="5" />
      <LineId Id="2573" Count="0" />
      <LineId Id="2572" Count="0" />
      <LineId Id="2508" Count="3" />
      <LineId Id="2561" Count="2" />
      <LineId Id="2512" Count="2" />
      <LineId Id="2521" Count="0" />
      <LineId Id="2564" Count="0" />
      <LineId Id="2522" Count="0" />
      <LineId Id="2525" Count="4" />
      <LineId Id="2574" Count="0" />
      <LineId Id="2571" Count="0" />
      <LineId Id="2530" Count="5" />
      <LineId Id="2539" Count="0" />
      <LineId Id="2566" Count="0" />
      <LineId Id="2565" Count="0" />
      <LineId Id="2543" Count="6" />
      <LineId Id="2569" Count="1" />
      <LineId Id="2618" Count="0" />
      <LineId Id="2606" Count="0" />
      <LineId Id="2575" Count="0" />
      <LineId Id="2276" Count="0" />
      <LineId Id="2586" Count="0" />
      <LineId Id="2577" Count="7" />
      <LineId Id="2587" Count="1" />
      <LineId Id="2605" Count="0" />
      <LineId Id="2589" Count="4" />
      <LineId Id="2585" Count="0" />
      <LineId Id="2277" Count="4" />
      <LineId Id="2613" Count="0" />
      <LineId Id="2284" Count="5" />
      <LineId Id="2614" Count="0" />
      <LineId Id="2292" Count="23" />
      <LineId Id="2619" Count="2" />
      <LineId Id="2317" Count="1" />
      <LineId Id="2622" Count="2" />
      <LineId Id="2320" Count="26" />
      <LineId Id="2629" Count="2" />
      <LineId Id="2348" Count="0" />
      <LineId Id="2594" Count="0" />
      <LineId Id="2596" Count="8" />
      <LineId Id="2595" Count="0" />
      <LineId Id="870" Count="0" />
      <LineId Id="2425" Count="2" />
      <LineId Id="2459" Count="0" />
      <LineId Id="2429" Count="0" />
      <LineId Id="2424" Count="0" />
    </LineIds>
    <LineIds Name="FB_Singulation.a_HoldProduct">
      <LineId Id="8" Count="5" />
    </LineIds>
    <LineIds Name="FB_Singulation.a_ResetGrabbers">
      <LineId Id="5" Count="9" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_Singulation.Grabber1">
      <LineId Id="29" Count="15" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Singulation.Grabber2">
      <LineId Id="20" Count="15" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Singulation.PinStop">
      <LineId Id="21" Count="15" />
      <LineId Id="10" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>